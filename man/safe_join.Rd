% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/inexact_join.R
\name{safe_join}
\alias{safe_join}
\title{Join two data frames safely}
\usage{
safe_join(x, y, expect = NULL, join = NULL, ...)
}
\arguments{
\item{x, y}{The left and right data sets to join.}

\item{expect}{Either \code{'x'}, \code{'y'}, or \code{c('x','y')} - the data sets you expect to be uniquely identified by the joining variables.}

\item{join}{A \code{join} or \code{inexact_join} function to run if \code{safe_join} determines your join is safe. By default, simply returns \code{TRUE} instead of running the join.}

\item{...}{Other arguments to be passed to the function specified in \code{join}. If performing an \code{inexact_join}, put the \code{var} and \code{jvar} arguments in as quoted variables.}
}
\description{
This function is a wrapper for the standard \code{dplyr} \code{join} functions and the \code{pmdplyr} \code{inexact_join} functions.
}
\details{
When performing a join, we generally expect that one or both of the joined data sets is uniquely identified by the set of joining variables.

If this is not true, the results of the join will often not be what you expect. Unfortunately, \code{join} does not warn you that you may have just done something strange.

This issue is especially likely to arise with panel data, where you may have multiple different data sets at different observation levels.

\code{safe_join} forces you to specify which of your data sets you think are uniquely identified by the joining variables. If you are wrong, it will return an error. If you are right, it will pass you on to your preferred \code{join} function, given in \code{join}. If \code{join} is not specified, it will just return \code{TRUE}.

\code{expect = 'x'}, \code{expect = 'y'}, and \code{expect = c('x','y')} are comparable to Stata's \code{merge 1:m}, \code{merge m:1}, and \code{merge 1:1}, respectively.
}
\examples{
# left is panel data and i does not uniquely identify observations
left <- data.frame(i = c(1, 1, 2, 2),
                   t = c(1, 2, 1, 2),
                   a = 1:4)
# right is individual-level data uniquely identified by i
right <- data.frame(i = c(1, 2),
                    b = 1:2)

# I think that I can do a one-to-one merge on i
# Forgetting that left is identified by i and t together
# So, this produces an error
\dontrun{
safe_join(left, right, expect = c('x', 'y'), join = left_join)
}

# If I realize I'm doing a many-to-one merge, that is correct,
# so safe_join will perform it for us
safe_join(left, right, expect = 'y', join = left_join)

}
